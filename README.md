[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18462180&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is the application of engineering principles to the design, development, testing, and maintenance of software.
 It's about applying a structured, disciplined approach to building reliable, efficient, and scalable software systems.
 
 Software engineers use project management skills to keep projects on time and within budget, which is essential for delivering successful software projects.
 Software engineers are responsible for building secure software that protects sensitive data from unauthorized access since security is constantly growing as cyber threats become more sophisticated.
Software engineering provides the tools and techniques needed to manage these complex systems.


Identify and describe at least three key milestones in the evolution of software engineering.

The Birth of Software Engineering (1968):   "software engineering" emerged at the 1968 NATO Software Engineering Conference. This conference brought about the recognition of a "software crisis," where software projects were frequently failing, exceeding budgets, and delivering unreliable products.  This milestone highlighted the need for a more disciplined and engineering-based approach to software development, moving away from purely craft-based methods. The conference and the subsequent discussions laid the foundation for establishing software engineering as a distinct discipline.
The Rise of Object-Oriented Programming (1970s - 1980s)
The development and popularization of object-oriented programming (OOP) revolutionized software engineering. OOP languages like Smalltalk (introduced in the 1970s) and later C++ (1983) and Java (1995) helped developers structure code into reusable objects, making large-scale software development more manageable. This paradigm shift improved code maintainability, reusability, and scalability, leading to modern software engineering best practices.
 The Agile Manifesto (2001 - Agile Development)
In response to the inefficiencies of heavyweight software development methodologies like Waterfall, a group of software developers published the Agile Manifesto in 2001. Agile introduced iterative, customer-focused development practices that prioritized working software, collaboration, and flexibility over rigid documentation and processes. Agile methodologies like Scrum and Kanban have since become industry standards, enabling teams to adapt quickly to changing requirements and deliver software more efficiently.


List and briefly explain the phases of the Software Development Life Cycle.

Planning: This initial phase defines the project's scope, objectives, and feasibility. It involves understanding the problem, identifying user needs, and determining project goals, timelines, and resources.  The output of this phase is typically a project plan.

Requirements Analysis: In this phase, detailed requirements are gathered and documented. This involves eliciting requirements from stakeholders, analyzing them, and specifying them in a clear and testable format.  The result is a detailed requirements specification document.

Design:  Software architects and developers create system architecture, database models, and user interface designs. High-level and low-level design specifications are developed to guide implementation.

Implementation (Coding): This is where the actual software code is written based on the design specifications.  Programmers write code in the chosen programming language, following coding standards and guidelines.  The result is the working software code.

Testing:  The testing phase ensures that the software meets the specified requirements and is free from defects. Various testing methods are employed, such as unit testing, integration testing, system testing, and user acceptance testing.  The goal is to identify and fix bugs before deployment.

Deployment:  Once testing is complete and the software is deemed ready, it is deployed to the production environment. This may involve installation, configuration, and data migration.  The software is made available to end-users in this phase.

Maintenance:  After deployment, the software is continuously monitored for bugs, security vulnerabilities, and performance issues. Updates, patches, and enhancements are made based on user feedback and evolving requirements.







Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
Waterfall follows a fixed sequence: Planning to Requirements to Design to Development to Testing to Deployment to Maintenance, while agile works in short cycles known as sprints/iterations, allowing continuous feedback and improvements.
Waterfall is rigid; changes are difficult to accommodate once development starts, while agile is highly flexible for it accommodates changes even late in development.
In waterfall testing is performed after development is completed, while in agile there is continuous testing throughout the development cycle.
When to Use Waterfall:
Government or Military Projects – Require extensive documentation and strict regulatory compliance.
Healthcare Systems – Where safety, legal, and compliance issues require rigid structures.
When to Use Agile
Startups Developing an MVP (Minimum Viable Product) – Frequent iterations and user feedback help refine the product.
E-commerce or Web Applications – Require constant updates based on user trends and feedback.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
 Software Developer: Writing clean, efficient, and maintainable code.
                    Implementing software features based on design and business requirements.
                   Debug and fix issues in the codebase.
                   Optimizing software performance and scalability.
                   Documenting code and technical specifications.
Quality Assurance (QA) Engineer: Design and execute test cases to identify defects.
                                  Performing functional, regression, performance, and security testing.
                                 Automating testing processes to improve efficiency.
                                 Reporting and tracking bugs, ensuring they are fixed before deployment.
                                Ensuring compliance with software quality standards.
Project Manager: oversees the planning, execution, and delivery of software projects
Defining project scope, objectives, and timelines.
Allocating resources and managing team workloads.
Communicating with stakeholders to gather requirements and provide updates.
Monitoring project progress and ensuring deadlines are met.
Managing risks and resolving conflicts within the team.
Ensuring that the project stays within budget and meets business goals.
                              

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
IDEs
 Offer features like syntax highlighting, auto-completion, and error detection, speeding up coding.
 Built-in debugging tools allow step-by-step execution of code, making it easier to identify issues.
 PyCharm and Visual Studio Code (VS Code).
 VCS
 Multiple developers can work on the same project without overwriting each other’s code.
Maintains a record of all code changes, allowing developers to revert to previous versions if needed.
Git and Apache Subversion

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
Clients or stakeholders often change requirements mid-project, leading to scope creep and delays.
Finding and fixing bugs can be time-consuming and frustrating, especially in large codebases.
Developers often work under pressure to deliver software within strict deadlines.
Strategy:
Use Agile methodologies to accommodate changes incrementally.
Use debugging tools and log files to pinpoint issues quickly and write unit tests to catch bugs early in development.
Use task management tools like trello to prioritize tasks effectively and break the project into smaller, manageable milestones using the SDLC model.


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
 Unit Testing is testing individual components or functions of the software in isolation.
Unit testing ensures each function or module works correctly.
Helps catch bugs early, reducing future debugging costs.
Supports test-driven development (TDD) by writing tests before code.

Integration Testing is testing how multiple modules or components interact with each other.
Identifies issues in data flow and communication between components.
Ensures APIs, databases, and third-party services work together correctly.
Helps detect interface mismatches and integration issues early.

System Testing is testing the entire software system as whole to verify it meets requirements.
System testing ensures that the complete system functions as expected.
Validates end-to-end workflows and overall system performance.
Identifies issues not detected during unit or integration testing.


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is the  designing and refining of prompts to effectively communicate with AI models and generate accurate, relevant, and useful responses. 
Enhances quality responses by crafting prompts that ensure precise and relevant AI outputs.
Optimizes efficiency since it saves time by reducing the need for multiple iterations or clarifications.
Helps AI generate solutions for coding, content creation, and decision-making.


Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
Tell me about technology.
Describe three ways artificial intelligence is improving healthcare, with real-world examples.


Clear – Specifies AI’s role in healthcare.
Specific – Focuses on three improvements.
Concise – Removes unnecessary wording while keeping the request detailed.
